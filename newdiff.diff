diff --git a/src/chain.h b/src/chain.h
index 6c952a1..7b2a146 100755
--- a/src/chain.h
+++ b/src/chain.h
@@ -296,7 +296,7 @@ public:
 
     uint256 GetBlockPoWHash() const
     {
-        return GetBlockHeader().GetPoWHash();
+        return GetBlockHeader().GetPoWHash(nHeight);
     }
 
     int64_t GetBlockTime() const
diff --git a/src/pow.cpp b/src/pow.cpp
index 706af53..db0d10d 100755
--- a/src/pow.cpp
+++ b/src/pow.cpp
@@ -82,13 +82,8 @@ unsigned int static KimotoGravityWell(const CBlockIndex* pindexLast, const Conse
     return bnNew.GetCompact();
 }
 
-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)
+unsigned int GetNextWorkRequiredLegacy(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)
 {
-    // we use the old retarget algo as a shim
-    if (algoSelect > 0)
-        return KimotoGravityWell(pindexLast, params);
-
-    // but if conditional isnt met, works as it should
     assert(pindexLast != nullptr);
     unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();
 
@@ -164,6 +159,18 @@ unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nF
     return bnNew.GetCompact();
 }
 
+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)
+{
+    assert(pindexLast != nullptr);
+    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();
+
+    if (pindexLast->nHeight+1 > 175000 && pindexLast->nHeight+1 < 175010)
+        return nProofOfWorkLimit;
+    if (pindexLast->nHeight+1 <= 175000)
+        return GetNextWorkRequiredLegacy(pindexLast, pblock, params);
+    return KimotoGravityWell(pindexLast, params);
+}
+
 bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)
 {
     bool fNegative;
diff --git a/src/primitives/block.cpp b/src/primitives/block.cpp
index 7ee7b00..4e51768 100755
--- a/src/primitives/block.cpp
+++ b/src/primitives/block.cpp
@@ -11,37 +11,20 @@
 #include <crypto/common.h>
 #include <crypto/scrypt.h>
 #include <crypto/allium.h>
-#include <consensus/params.h>
 #include <chainparams.h>
-#include <validation.h>
-
-uint8_t algoSelect = 0;
-//class validation request;
-
-//uint8_t algoSelect
-//{
-    //return algoSelect;
-//}
 
 uint256 CBlockHeader::GetHash() const
 {
     return SerializeHash(*this);
 }
 
-uint256 CBlockHeader::GetPoWHash() const
-{
-    if (algoSelect == 0)
-       return GetLegacyPoWHash();
-
-    uint256 thash;
-    allium_hash(BEGIN(nVersion), BEGIN(thash));
-    return thash;
-}
-
-uint256 CBlockHeader::GetLegacyPoWHash() const
+uint256 CBlockHeader::GetPoWHash(const int nHeight) const
 {
     uint256 thash;
-    scrypt_1024_1_1_256(BEGIN(nVersion), BEGIN(thash));
+    if (nHeight > 175000)
+        allium_hash(BEGIN(nVersion), BEGIN(thash));
+    else
+        scrypt_1024_1_1_256(BEGIN(nVersion), BEGIN(thash));
     return thash;
 }
 
diff --git a/src/primitives/block.h b/src/primitives/block.h
index 1dcbb94..3660459 100755
--- a/src/primitives/block.h
+++ b/src/primitives/block.h
@@ -11,13 +11,6 @@
 #include <uint256.h>
 #include <crypto/allium.h>
 
-extern uint8_t algoSelect;
-
-    //extern "C" 
-    //{
-    //uint8_t algoSelect;
-    //}
-
 /** Nodes collect new transactions into a block, hash them into a hash tree,
  * and scan through nonce values to make the block's hash satisfy proof-of-work
  * requirements.  When they solve the proof-of-work, they broadcast the block
@@ -71,11 +64,7 @@ public:
 
     uint256 GetHash() const;
 
-    uint256 GetPoWHash() const;
-
-    //uint256 GetPowHash(uint8_t selection);
-
-    uint256 GetLegacyPoWHash() const;
+    uint256 GetPoWHash(int Height) const;
 
     int64_t GetBlockTime() const
     {
diff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp
index c23aa88..f8bcc2a 100755
--- a/src/rpc/mining.cpp
+++ b/src/rpc/mining.cpp
@@ -126,7 +126,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen
             LOCK(cs_main);
             IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);
         }
-        while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetPoWHash(), pblock->nBits, Params().GetConsensus())) {
+        while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetPoWHash(nHeight), pblock->nBits, Params().GetConsensus())) {
             ++pblock->nNonce;
             --nMaxTries;
         }
diff --git a/src/validation.cpp b/src/validation.cpp
index 72806ab..6acdaba 100755
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -1104,7 +1104,7 @@ static bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMes
     return true;
 }
 
-bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams)
+bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const int nHeight, const Consensus::Params& consensusParams)
 {
     block.SetNull();
 
@@ -1122,8 +1122,8 @@ bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus:
     }
 
     // Check the header
-    if (!CheckProofOfWork(block.GetPoWHash(), block.nBits, consensusParams))
-        return error("ReadBlockFromDisk: Errors in block header at %s", pos.ToString());
+    if (!CheckProofOfWork(block.GetPoWHash(nHeight), block.nBits, consensusParams))
+        return error("ReadBlockFromDisk: Errors in block header at %s (block %d)", pos.ToString(), nHeight);
 
     return true;
 }
@@ -1136,7 +1136,7 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus
         blockPos = pindex->GetBlockPos();
     }
 
-    if (!ReadBlockFromDisk(block, blockPos, consensusParams))
+    if (!ReadBlockFromDisk(block, blockPos, pindex->nHeight, consensusParams))
         return false;
     if (block.GetHash() != pindex->GetBlockHash())
         return error("ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s",
@@ -1790,19 +1790,12 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl
 {
     AssertLockHeld(cs_main);
     assert(pindex);
+
     // pindex->phashBlock can be null if called by CreateNewBlock/TestBlockValidity
     assert((pindex->phashBlock == nullptr) ||
            (*pindex->phashBlock == block.GetHash()));
     int64_t nTimeStart = GetTimeMicros();
 
-
-
-    // If we meet this blockheight, signal a switch in PoW algorithm
-    if (algoSelect == 0 && (pindex->nHeight > Params().GetConsensus().ForkHeight())) {
-        algoSelect = 1;
-        LogPrintf("* Allium algorithm activated at blockheight %d\n", Params().GetConsensus().ForkHeight());
-    }
-
     // Check it again in case a previous version let a bad block in
     // NOTE: We don't currently (re-)invoke ContextualCheckBlock() or
     // ContextualCheckBlockHeader() here. This means that if we add a new
@@ -2994,9 +2987,16 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,
 
 static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)
 {
-	return true;
+    // Get prev block index
+    CBlockIndex* pindexPrev = NULL;
+    int nHeight = 0;
+    BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);
+    if (mi != mapBlockIndex.end()) {
+        pindexPrev = mi->second;
+        nHeight = pindexPrev->nHeight + 1;
+    }
     // Check proof of work matches claimed amount
-    if (fCheckPOW && !CheckProofOfWork(block.GetPoWHash(), block.nBits, consensusParams))
+    if (fCheckPOW && !CheckProofOfWork(block.GetPoWHash(nHeight), block.nBits, consensusParams))
         return state.DoS(50, false, REJECT_INVALID, "high-hash", false, "proof of work failed");
 
     return true;
@@ -4341,7 +4341,8 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB
                     while (range.first != range.second) {
                         std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;
                         std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();
-                        if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))
+                        const int nHeight = mapBlockIndex[it->first]->nHeight;
+                        if (ReadBlockFromDisk(*pblockrecursive, it->second, nHeight, chainparams.GetConsensus()))
                         {
                             LogPrint(BCLog::REINDEX, "%s: Processing out of order child %s of %s\n", __func__, pblockrecursive->GetHash().ToString(),
                                     head.ToString());
diff --git a/src/validation.h b/src/validation.h
index 12d6c08..4677198 100755
--- a/src/validation.h
+++ b/src/validation.h
@@ -46,17 +46,6 @@ struct ChainTxData;
 struct PrecomputedTransactionData;
 struct LockPoints;
 
-
-// PoW algorithm in use
-
-//extern uint8_t algoSelect;
-
-//extern "C" 
-//{
-   // uint8_t algoSelect;
-//}
-
-
 /** Default for -whitelistrelay. */
 static const bool DEFAULT_WHITELISTRELAY = true;
 /** Default for -whitelistforcerelay. */
